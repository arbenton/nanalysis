octave:18> % 3.4.6
octave:19> f = @(x) 3.*x.*exp(x) - exp(2.*x);
octave:20> x = [1.00 1.05];
octave:21> y = f(x);
octave:22> type hermite
hermite is the user-defined function defined from: /home/andrew/Documents/school/numerical_analysis/code/interpolation/hermite.m

function [P, v] = hermite(x, y, yp, p)

    n = length(x);
    z = zeros(2*n,1);
    Q = zeros(2*n,2*n);

    for i=1:n
        z(2*i-1) = x(i);
        z(2*i) = x(i);
        Q(2*i-1,1) = y(i);
        Q(2*i,1) = y(i);
        Q(2*i,2) = yp(i);
        if i~=1
            Q(2*i-1,2) = (Q(2*i-1,1)-Q(2*i-2,1)) / (z(2*i-1)-z(2*i-2));
        end
    end
    
    for i=2:2*n-1
       for j=2:i
            Q(i+1,j+1) = (Q(i+1,j)-Q(i,j))/(z(i+1)-z(i-j+1));
        end
    end

    P = diag(Q);

    if exist('p', 'var')
        v = P(1);
        for i=1:2*n-1
            v = v + P(i+1)*prod(p*ones(i,1)-z(1:i));
        end
    end
end

octave:23> fp = @(x) 3.*exp(x) + 3.*x.*exp(x) - 2.*exp(2.*x);
octave:24> yp = fp(x);
octave:25> [P, v] = hermite(x, y, yp, 1.03)
P =

   0.76579
   1.53158
  -2.77489
  -4.75024

v =  0.80932
octave:26> x = [1.00 1.05 1.07];
octave:27> y = f(x);
octave:28> yp = fp(x);
octave:29> [P, v] = hermite(x, y, yp, 1.03)
P =

   0.76579
   1.53158
  -2.77489
  -4.75024
  -3.50430
  -1.70781

v =  0.80932
octave:30> % 3.4.9
octave:30> x = [0 3 5 8 13];
octave:31> y = [0 225 383 623 993];
octave:32> yp = [75 77 80 74 72];
octave:34> [P, v] = hermite(x, y, yp, 1.00)
P =

    0.00000
   75.00000
    0.00000
    0.22222
   -0.03111
   -0.00644
    0.00226
   -0.00091
    0.00013
   -0.00002

v =  76.259

octave:3> x = [0 3 5 8 13];
octave:4> y = [0 225 383 623 993];
octave:5> yp = [75 77 80 74 72];
octave:9> syms p
octave:10> [P, v] = hermite(x, y, yp, p)
P =

    0.00000
   75.00000
    0.00000
    0.22222
   -0.03111
   -0.00644
    0.00226
   -0.00091
    0.00013
   -0.00002

v = (sym)

        2                 2        2        2       2        2        2        2       2                2        2       2        2        2       2                2      2        2      2               
    10⋅p ⋅(p - 13)⋅(p - 8) ⋅(p - 5) ⋅(p - 3)    19⋅p ⋅(p - 8) ⋅(p - 5) ⋅(p - 3)    35⋅p ⋅(p - 8)⋅(p - 5) ⋅(p - 3)    39⋅p ⋅(p - 5) ⋅(p - 3)    29⋅p ⋅(p - 5)⋅(p - 3)    7⋅p ⋅(p - 3)    2⋅p ⋅(p - 3)       
  - ───────────────────────────────────────── + ──────────────────────────────── - ─────────────────────────────── + ─────────────────────── - ────────────────────── - ───────────── + ──────────── + 75⋅p
                      494471                                 145564                             38327                         17227                     4500                 225             9             

octave:14> vd = diff(v);
ctave:21> solve(vd == 80.6667, p)
ans = {}(0x0)
octave:22> solve(vd == 80.00, p)
ans = (sym) 5
octave:36> % 3.5.2
octave:37> x = [0 1 2];
octave:38> y = [0 1 2];
octave:39> type clamped_cubic_splines
clamped_cubic_splines is the user-defined function defined from: /home/andrew/Documents/school/numerical_analysis/code/interpolation/clamped_cubic_splines.m

function [S] = clamped_cubic_splines (x, y, yp)
    
    n = length(x)-1;
    m = n - 1;
    A = y;
    h = zeros(1, m+1);

    for i=1:n
        h(i) = x(i+1)-x(i);
    end
    
    alpha = zeros(1, n+1);
    alpha(1) = 3.0*(A(2)-A(1))/h(1)-3.0*yp(1);
    alpha(end) = 3.0*yp(2)-3.0*(A(n+1)-A(n))/h(n);

    for i=1:m
        alpha(i+1) = 3.0*(A(i+2)*h(i)-A(i+1)*(x(i+2)-x(i))+A(i)*h(i+1))/(h(i+1)*h(i));
    end

    l = zeros(1,n+1);
    mu = zeros(1,n+1);
    z = zeros(1,n+1);
    l(1) = 1;
    mu(1) = 0;
    z(1) = 0;
    
    for i=1:m
        l(i+1) = 2*(x(i+2)-x(i))-h(i)*mu(i);
        mu(i+1) = h(i+1)/l(i+1);
        z(i+1) = (alpha(i+1)-h(i)*z(i))/l(i+1);
    end

    l(n+1) = h(n)*(2-mu(n));
    z(n+1) = (alpha(n+1)-h(n)*z(n))/l(n+1);

    B = zeros(1,n+1);
    C = zeros(1,n+1);
    D = zeros(1,n+1);
    C(n+1) = z(n+1);
    
    for i = 1:n
        j = n-i;
        C(j+1) = z(j+1)-mu(j+1)*C(j+2);
        B(j+1) = (A(j+2)-A(j+1))/h(j+1)-h(j+1)*(C(j+2)+2.0*C(j+1))/3.0;
        D(j+1) = (C(j+2)-C(j+1))/(3.0*h(j+1));
    end

    S = [A; B; C; D]';
end

octave:40> S = clamped_cubic_splines(x, y, [1 1])
S =

   0   1   0   0
   1   1   0   0
   2   0   0   0


octave:42> %3.5.4
octave:43> x = [-1 -.5 0 .5];
octave:44> y = [.86199480 .95802009 1.0986123 1.2943767];
octave:45> type natural_cubic_splines
natural_cubic_splines is the user-defined function defined from: /home/andrew/Documents/school/numerical_analysis/code/interpolation/natural_cubic_splines.m

function [S] = natural_cubic_splines (x, y, p)
    
    n = length(x)-1;
    m = n - 1;
    A = y;
    h = zeros(1, n);
    alpha = h;

    for i=1:n
        h(i) = x(i+1)-x(i);
    end
    
    for i=1:m
        alpha(i+1) = 3.0*(A(i+2)*h(i)-A(i+1)*(x(i+2)-x(i))+A(i)*h(i+1))/(h(i+1)*h(i));
    end

    l = zeros(1,n+1);
    mu = l;
    z = l;
    l(1) = 1;
    mu(1) = 0;
    z(1) = 0;
    
    for i=1:m
        l(i+1) = 2*(x(i+2)-x(i))-h(i)*mu(i);
        mu(i+1) = h(i+1)/l(i+1);
        z(i+1) = (alpha(i+1)-h(i)*z(i))/l(i+1);
    end

    l(end) = 1;
    z(end) = 0;

    B = zeros(1,n+1);
    C = zeros(1,n+1);
    D = zeros(1,n+1);
    C(end) = z(end);
    
    for i = 0:m
        j = m-i;
        C(j+1) = z(j+1)-mu(j+1)*C(j+2);
        B(j+1) = (A(j+2)-A(j+1))/h(j+1)-h(j+1)*(C(j+2)+2.0*C(j+1))/3.0;
        D(j+1) = (C(j+2)-C(j+1))/(3.0*h(j+1));
    end

    S = [A; B; C; D]';
end

octave:46> S = natural_cubic_splines(x, y)
S =

   0.86199   0.17564   0.00000   0.06565
   0.95802   0.22488   0.09848   0.02828
   1.09861   0.34456   0.14090  -0.09393
   1.29438   0.00000   0.00000   0.00000

octave:47> % 3.5.24
octave:47> x = [0 10 20 30 40 50];
octave:48> y = [179323 203302 226542 249633 281422 308746];
octave:49> p = [-10 15 54 60];
octave:50> interp1(x, y, p, 'spline')
ans =

           NA   2.1521e+05           NA           NA

octave:51> interp1(x, y, p, 'spline', 'extrap')
ans =

   1.5768e+05   2.1521e+05   3.1404e+05   3.1202e+05

